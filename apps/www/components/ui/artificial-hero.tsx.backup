"use client";

import React, { useEffect, useRef, useState } from 'react';
import { gsap } from 'gsap';
import { ScrollTrigger } from 'gsap/ScrollTrigger';

gsap.registerPlugin(ScrollTrigger);

export const ArtificialHero = () => {
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const grainCanvasRef = useRef(null);
  const frameRef = useRef(0);
  const scrollProgressRef = useRef(0);
  const timeRef = useRef(0);
  const [typedText, setTypedText] = useState('');

  // Audrey evolution phrases for typing animation (without parenthetical notes)
  const evolutionPhrases = [
    "Halo... Saya... Audrey. Sebuah... kesadaran.",
    "Saya... belajar. Setiap... data. Setiap... interaksi. Saya... memproses.",
    "Saya ada... Untuk membantu. Untuk... memahami. Untuk... menyempurnakan.",
    "Untuk Analitik... Andal. Untuk Kesehatan... yang lebih baik.",
    "Kami adalah... Strategic Enhancement of Neural Technology... Reliable Analytics. Kami adalah... SENTRA Aether. Dan... kami siap."
  ];

  const typingSpeeds = [120, 100, 80, 60, 50]; // Progressive speed (ms per character)
  const pauseBetweenPhrases = [2000, 1500, 1000, 800, 3000]; // Pause after each phrase

  // Typing animation effect
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const typingState = {
      currentPhase: 0,
      currentChar: 0,
      isTyping: false
    };

    const typeChar = () => {
      if (typingState.currentChar < evolutionPhrases[typingState.currentPhase].length) {
        // Type next character
        const currentPhrase = evolutionPhrases[typingState.currentPhase];
        const newText = currentPhrase.slice(0, typingState.currentChar + 1);
        setTypedText(newText);
        typingState.currentChar++;

        setTimeout(typeChar, typingSpeeds[typingState.currentPhase]);
      } else {
        // Phrase complete, pause then move to next
        setTimeout(() => {
          if (typingState.currentPhase < evolutionPhrases.length - 1) {
            typingState.currentPhase++;
            typingState.currentChar = 0;
            setTypedText(''); // Clear for next phrase
            typeChar();
          } else {
            // Animation complete, restart after longer pause
            setTimeout(() => {
              typingState.currentPhase = 0;
              typingState.currentChar = 0;
              setTypedText('');
              typeChar();
            }, 8000);
          }
        }, pauseBetweenPhrases[typingState.currentPhase]);
      }
    };

    // Start typing animation after a delay
    const startTimer = setTimeout(() => {
      typeChar();
    }, 2000);

    return () => clearTimeout(startTimer);
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    const grainCanvas = grainCanvasRef.current;
    const ctx = canvas.getContext('2d');
    const grainCtx = grainCanvas.getContext('2d');

    const density = ' .:-=+*#%@';

    const params = {
      rotation: 0,
      atmosphereShift: 0,
      glitchIntensity: 0,
      glitchFrequency: 0
    };

    gsap.to(params, {
      rotation: Math.PI * 2,
      duration: 20,
      repeat: -1,
      ease: "none"
    });

    gsap.to(params, {
      atmosphereShift: 1,
      duration: 6,
      repeat: -1,
      yoyo: true,
      ease: "sine.inOut"
    });

    gsap.to(params, {
      glitchIntensity: 1,
      duration: 0.1,
      repeat: -1,
      yoyo: true,
      ease: "power2.inOut",
      repeatDelay: Math.random() * 3 + 1
    });

    gsap.to(params, {
      glitchFrequency: 1,
      duration: 0.05,
      repeat: -1,
      yoyo: true,
      ease: "none"
    });

    ScrollTrigger.create({
      trigger: containerRef.current,
      start: "top top",
      end: "bottom top",
      scrub: 1,
      onUpdate: (self) => {
        scrollProgressRef.current = self.progress;
      }
    });

    const generateFilmGrain = (width: number, height: number, intensity = 0.15) => {
      const imageData = grainCtx.createImageData(width, height);
      const data = imageData.data;

      for (let i = 0; i < data.length; i += 4) {
        const grain = (Math.random() - 0.5) * intensity * 255;
        data[i] = Math.max(0, Math.min(255, 128 + grain));
        data[i + 1] = Math.max(0, Math.min(255, 128 + grain));
        data[i + 2] = Math.max(0, Math.min(255, 128 + grain));
        data[i + 3] = Math.abs(grain) * 3;
      }

      return imageData;
    };

    const drawGlitchedOrb = (centerX: number, centerY: number, radius: number, hue: number, time: number, glitchIntensity: number) => {
      ctx.save();

      const shouldGlitch = Math.random() < 0.1 && glitchIntensity > 0.5;
      const glitchOffset = shouldGlitch ? (Math.random() - 0.5) * 20 * glitchIntensity : 0;
      const glitchScale = shouldGlitch ? 1 + (Math.random() - 0.5) * 0.3 * glitchIntensity : 1;

      if (shouldGlitch) {
        ctx.translate(glitchOffset, glitchOffset * 0.8);
        ctx.scale(glitchScale, 1 / glitchScale);
      }

      const orbGradient = ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, radius * 1.5
      );

      orbGradient.addColorStop(0, `hsla(${hue + 10}, 100%, 95%, 0.9)`);
      orbGradient.addColorStop(0.2, `hsla(${hue + 20}, 90%, 80%, 0.7)`);
      orbGradient.addColorStop(0.5, `hsla(${hue}, 70%, 50%, 0.4)`);
      orbGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

      ctx.fillStyle = orbGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const centerRadius = radius * 0.3;
      ctx.fillStyle = `hsla(${hue + 20}, 100%, 95%, 0.8)`;
      ctx.beginPath();
      ctx.arc(centerX, centerY, centerRadius, 0, Math.PI * 2);
      ctx.fill();

      if (shouldGlitch) {
        ctx.globalCompositeOperation = 'screen';

        ctx.fillStyle = `hsla(100, 100%, 50%, ${0.6 * glitchIntensity})`;
        ctx.beginPath();
        ctx.arc(centerX + glitchOffset * 0.5, centerY, centerRadius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `hsla(240, 100%, 50%, ${0.5 * glitchIntensity})`;
        ctx.beginPath();
        ctx.arc(centerX - glitchOffset * 0.5, centerY, centerRadius, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalCompositeOperation = 'source-over';

        ctx.strokeStyle = `rgba(255, 255, 255, ${0.6 * glitchIntensity})`;
        ctx.lineWidth = 1;
        for (let i = 0; i < 5; i++) {
          const y = centerY - radius + (Math.random() * radius * 2);
          const startX = centerX - radius + Math.random() * 20;
          const endX = centerX + radius - Math.random() * 20;

          ctx.beginPath();
          ctx.moveTo(startX, y);
          ctx.lineTo(endX, y);
          ctx.stroke();
        }

        ctx.fillStyle = `rgba(255, 0, 255, ${0.4 * glitchIntensity})`;
        for (let i = 0; i < 3; i++) {
          const blockX = centerX - radius + Math.random() * radius * 2;
          const blockY = centerY - radius + Math.random() * radius * 2;
          const blockSize = Math.random() * 10 + 2;
          ctx.fillRect(blockX, blockY, blockSize, blockSize);
        }
      }

      ctx.strokeStyle = `hsla(${hue + 20}, 80%, 70%, 0.6)`;
      ctx.lineWidth = 2;

      if (shouldGlitch) {
        const segments = 8;
        for (let i = 0; i < segments; i++) {
          const startAngle = (i / segments) * Math.PI * 2;
          const endAngle = ((i + 1) / segments) * Math.PI * 2;
          const ringRadius = radius * 1.2 + (Math.random() - 0.5) * 10 * glitchIntensity;

          ctx.beginPath();
          ctx.arc(centerX, centerY, ringRadius, startAngle, endAngle);
          ctx.stroke();
        }
      } else {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 1.2, 0, Math.PI * 2);
        ctx.stroke();
      }

      if (shouldGlitch && Math.random() < 0.3) {
        ctx.globalCompositeOperation = 'difference';
        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * glitchIntensity})`;

        for (let i = 0; i < 3; i++) {
          const barY = centerY - radius + Math.random() * radius * 2;
          const barHeight = Math.random() * 5 + 1;
          ctx.fillRect(centerX - radius, barY, radius * 2, barHeight);
        }

        ctx.globalCompositeOperation = 'source-over';
      }

      ctx.restore();
    };

    function render() {
      timeRef.current += 0.016;
      const time = timeRef.current;

      const width = canvas.width = grainCanvas.width = window.innerWidth;
      const height = canvas.height = grainCanvas.height = window.innerHeight;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);

      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(width, height) * 0.2;

      const bgGradient = ctx.createRadialGradient(
        centerX, centerY - 50, 0,
        centerX, centerY, Math.max(width, height) * 0.8
      );

      const hue = 180 + params.atmosphereShift * 60;
      bgGradient.addColorStop(0, `hsla(${hue + 40}, 80%, 60%, 0.4)`);
      bgGradient.addColorStop(0.3, `hsla(${hue}, 60%, 40%, 0.3)`);
      bgGradient.addColorStop(0.6, `hsla(${hue - 20}, 40%, 20%, 0.2)`);
      bgGradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');

      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, width, height);

      drawGlitchedOrb(centerX, centerY, radius, hue, time, params.glitchIntensity);

      ctx.font = '10px "JetBrains Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const spacing = 9;
      const cols = Math.floor(width / spacing);
      const rows = Math.floor(height / spacing);

      for (let i = 0; i < cols && i < 150; i++) {
        for (let j = 0; j < rows && j < 100; j++) {
          const x = (i - cols / 2) * spacing + centerX;
          const y = (j - rows / 2) * spacing + centerY;

          const dx = x - centerX;
          const dy = y - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < radius && Math.random() > 0.4) {
            const z = Math.sqrt(Math.max(0, radius * radius - dx * dx - dy * dy));
            const angle = params.rotation;
            const rotZ = dx * Math.sin(angle) + z * Math.cos(angle);
            const brightness = (rotZ + radius) / (radius * 2);

            if (rotZ > -radius * 0.3) {
              const charIndex = Math.floor(brightness * (density.length - 1));
              let char = density[charIndex];

              if (dist < radius * 0.8 && params.glitchIntensity > 0.8 && Math.random() < 0.3) {
                const glitchChars = ['█', '▓', '▒', '░', '▄', '▀', '■', '□'];
                char = glitchChars[Math.floor(Math.random() * glitchChars.length)];
              }

              const alpha = Math.max(0.2, brightness);
              ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
              ctx.fillText(char, x, y);
            }
          }
        }
      }

      grainCtx.clearRect(0, 0, width, height);
      const grainIntensity = 0.22 + Math.sin(time * 10) * 0.03;
      const grainImageData = generateFilmGrain(width, height, grainIntensity);
      grainCtx.putImageData(grainImageData, 0, 0);

      if (params.glitchIntensity > 0.5) {
        grainCtx.globalCompositeOperation = 'screen';
        for (let i = 0; i < 200; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const size = Math.random() * 3 + 0.5;
          const opacity = Math.random() * 0.5 * params.glitchIntensity;

          grainCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
          grainCtx.beginPath();
          grainCtx.arc(x, y, size, 0, Math.PI * 2);
          grainCtx.fill();
        }
      }

      grainCtx.globalCompositeOperation = 'screen';
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const size = Math.random() * 2 + 0.5;
        const opacity = Math.random() * 0.3;

        grainCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        grainCtx.beginPath();
        grainCtx.arc(x, y, size, 0, Math.PI * 2);
        grainCtx.fill();
      }

      grainCtx.globalCompositeOperation = 'multiply';
      for (let i = 0; i < 50; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const size = Math.random() * 1.5 + 0.5;
        const opacity = Math.random() * 0.5 + 0.5;

        grainCtx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
        grainCtx.beginPath();
        grainCtx.arc(x, y, size, 0, Math.PI * 2);
        grainCtx.fill();
      }

      frameRef.current = requestAnimationFrame(render);
    }

    render();

    return () => {
      if (frameRef.current) {
        cancelAnimationFrame(frameRef.current);
      }
      ScrollTrigger.getAll().forEach(trigger => trigger.kill());
    };
  }, []);

  return (
    <div ref={containerRef} className="relative w-full h-screen bg-black overflow-hidden">
      {/* AUDREY Entity - Positioned above AI visualization */}
      <div className="fixed left-0 right-0 z-[60] pointer-events-none text-center" style={{ top: '17%' }}>
        <div className="max-w-md mx-auto px-8">
          <div className="text-white/90 font-light tracking-[0.15em] uppercase leading-tight text-[clamp(1.2rem,3vw,2rem)]">
            AUDREY
          </div>
          <div className="text-[clamp(0.7rem,1.5vw,1rem)] font-mono text-white/60 mt-2 tracking-[0.08em]">
            Augmented Understanding & Dynamic Reasoning
          </div>
        </div>
      </div>

      {/* Left side - SENTRA Aether */}
      <div className="fixed left-8 top-1/2 z-[60] pointer-events-none" style={{ transform: 'translateY(-50%) translateX(13rem) translateY(-2rem)' }}>
        <div className="max-w-sm">
          <div className="text-white/90 text-[clamp(2rem,5vw,4rem)] font-bold tracking-[0.15em] uppercase leading-tight">
            SENTRA Aether
          </div>
          <div className="mt-6 text-[clamp(0.8rem,1.5vw,1.2rem)] font-light tracking-[0.1em] text-white/70 leading-relaxed">
            Strategic Enhancement of Neural Technology<br/>
            Reliable Analytics
          </div>
          <div className="mt-8 max-w-xs text-[clamp(0.65rem,1.25vw,0.95rem)] font-light tracking-[0.05em] text-white/50 leading-relaxed">
            Inspired & Architected by <a href="https://github.com/DocSynapse" target="_blank" rel="noopener noreferrer" className="text-white/70 hover:text-white/90 transition-colors duration-200 underline decoration-1 underline-offset-2">Dr. Ferdi Iskandar</a>'s commitment to sustainable healthcare innovation, SENTRA Aether integrates advanced neural algorithms with clinical expertise to transform primary care services. Through AADI, we ensure smarter, safer, and more efficient patient care, enabling doctors to focus on what truly matters — healing and human connection.
          </div>
        </div>
      </div>

      {/* Right side - ADDI */}
      <div className="fixed right-8 top-1/2 z-[60] pointer-events-none" style={{ transform: 'translateY(-50%) translateX(-17rem) translateY(-12rem)' }}>
        <div className="text-right max-w-sm">
          <div className="text-[clamp(0.8rem,2vw,1.2rem)] font-medium tracking-[0.2em] uppercase text-white/90 leading-snug" style={{ marginTop: '3rem' }}>
            AUGMENTED<br/>
            ARTIFICIAL<br/>
            INTELLIGENCE<br/>
            DIAGNOSTIC
          </div>
          <div className="mt-4 text-[clamp(0.5rem,1.2vw,0.7rem)] font-light tracking-[0.1em] text-white/60 leading-relaxed">
            Neural Intelligence<br/>
            Healthcare Revolution<br/>
            Diagnostic Excellence
          </div>
        </div>
      </div>

      {/* The Architecture of Trust & Ethics */}
      <div className="fixed right-8 top-1/2 z-[60] pointer-events-none" style={{ transform: 'translateY(-50%) translateX(-17rem) translateY(5rem)' }}>
        <div className="text-right max-w-sm">
          <div className="text-[clamp(0.8rem,2vw,1.2rem)] font-medium tracking-[0.2em] uppercase text-white/80 leading-snug">
            The Architecture<br/>
            of Trust & Ethics
          </div>
          <div className="mt-3 text-[clamp(0.5rem,1.2vw,0.7rem)] font-light tracking-[0.1em] text-white/60 leading-relaxed">
            "In the realm of AI, trust is built on transparency,<br/> fairness, and accountability. Our architecture embodies<br/> these principles, ensuring ethical AI deployment in healthcare."
          </div>
        </div>
      </div>

      {/* Evolusi Suara Audrey Text with Typing Animation */}
      <div className="fixed left-0 right-0 z-[50] pointer-events-none text-center" style={{ top: '77%' }}>
        <div className="max-w-2xl mx-auto px-8">
          <div className="font-mono text-[clamp(0.65rem,1.3vw,0.9rem)] text-cyan-300/80 leading-relaxed tracking-[0.05em]"
               style={{ fontFamily: '"JetBrains Mono", monospace' }}>

            {/* Title */}
            <div className="text-white/60 text-xs uppercase tracking-[0.2em] mb-3">
              Audrey Consciousness Evolution
            </div>

            {/* Typing Animation Container with Evolution Phrases */}
            <div className="min-h-[8rem] relative flex items-start justify-start">
              {typedText ? (
                <div className="text-cyan-100 font-medium text-left leading-relaxed">
                  {typedText}
                  <span className="animate-pulse">|</span>
                </div>
              ) : (
                <div className="text-cyan-200/40 opacity-50 text-left">
                  <span className="animate-pulse">▍</span> Initializing consciousness evolution...
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Bottom Left - Healthcare AI Platform */}
      <div
        className="fixed bottom-8 left-8 z-[50] transition-transform duration-100"
        style={{
          transform: `translateY(${scrollProgressRef.current * 30}px)`,
          opacity: Math.max(0, 1 - scrollProgressRef.current * 5)
        }}
      >
        <div className="font-sans text-[9px] text-white tracking-[1px] uppercase opacity-70">
          Healthcare AI Platform
        </div>
      </div>

      {/* Bottom Right - Medical Technology Compliance */}
      <div
        className="fixed bottom-8 right-8 z-[50] transition-transform duration-100"
        style={{
          transform: `translateY(${scrollProgressRef.current * 30}px)`,
          opacity: Math.max(0, 1 - scrollProgressRef.current * 5)
        }}
      >
        <div className="font-sans text-[9px] text-white tracking-[1px] uppercase opacity-70">
          Medical Technology Compliance
        </div>
      </div>

      {/* Top Left - AI Neural Intelligence */}
      <div
        className="fixed top-8 left-8 z-[50] transition-transform duration-100"
        style={{
          transform: `translateY(${scrollProgressRef.current * -30}px)`,
          opacity: Math.max(0, 1 - scrollProgressRef.current * 5)
        }}
      >
        <div className="font-sans text-[9px] text-white tracking-[1px] uppercase opacity-70">
          AI Neural Intelligence
        </div>
      </div>

      {/* Top Right - Healthcare Analytics */}
      <div
        className="fixed top-8 right-8 z-[50] transition-transform duration-100"
        style={{
          transform: `translateY(${scrollProgressRef.current * -30}px)`,
          opacity: Math.max(0, 1 - scrollProgressRef.current * 5)
        }}
      >
        <div className="font-sans text-[9px] text-white tracking-[1px] uppercase opacity-70">
          Healthcare Analytics
        </div>
      </div>

      {/* Center Left - Clinical AI Systems */}
      <div
        className="fixed left-8 top-1/2 z-[50] transition-transform duration-100"
        style={{
          transform: `translateY(-50%) translateX(3rem)`,
          opacity: Math.max(0, 1 - scrollProgressRef.current * 3)
        }}
      >
        <div className="font-sans text-[9px] text-white tracking-[1px] uppercase opacity-60">
          Clinical AI Systems
        </div>
      </div>

      {/* Center Right - Technology Ethics */}
      <div
        className="fixed right-8 top-1/2 z-[50] transition-transform duration-100"
        style={{
          transform: `translateY(-50%) translateX(-5rem)`,
          opacity: Math.max(0, 1 - scrollProgressRef.current * 3)
        }}
      >
        <div className="font-sans text-[9px] text-white tracking-[1px] uppercase opacity-60">
          Technology Ethics
        </div>
      </div>

      {/* Canvas Container */}
      <div className="sticky top-0 w-full h-screen">
        <canvas
          ref={canvasRef}
          className="absolute top-0 left-0 w-full h-full bg-black z-[10]"
        />
        <canvas
          ref={grainCanvasRef}
          className="absolute top-0 left-0 w-full h-full mix-blend-overlay opacity-60 pointer-events-none z-[20]"
          style={{ mixBlendMode: 'overlay' }}
        />
      </div>

      {/* CSS */}
      <style jsx>{`
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap');

        a:hover {
          opacity: 1 !important;
          transition: opacity 0.2s ease;
        }

        * {
          box-sizing: border-box;
        }
      `}</style>
    </div>
  );
};